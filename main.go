package main

import (
	"bytes"
	"google.golang.org/protobuf/proto"
	plugin "google.golang.org/protobuf/types/pluginpb"
	"io"
	"log"
	"os"
	"strings"
	"text/template"
)

type Generator struct {
	Request   *plugin.CodeGeneratorRequest
	Response  *plugin.CodeGeneratorResponse
	Template  string
	ProtoPath string
}

type Service struct {
	Package              string
	GoPackage            *string
	CsharpProtoNamespace *string
	CsharpServiceName    string
	Name                 string
	ProtoName            string
	Methods              []Rpc
	UseEmpty             bool
}

type Rpc struct {
	Name         string
	Request      string
	RequestDesc  string
	Response     string
	ResponseDesc string
	Scopes       []string
	Messages     map[string]string
	PushEvent    bool
	Public       bool
	Debug        bool
}

var (
	protoPath   string
	mainPckName string
)

func main() {
	// os.Stdin will contain data which will unmarshal into the following object:
	// https://godoc.org/github.com/golang/protobuf/protoc-gen-go/plugin#CodeGeneratorRequest
	req := &plugin.CodeGeneratorRequest{}
	resp := &plugin.CodeGeneratorResponse{}

	data, err := io.ReadAll(os.Stdin)
	if err != nil {
		panic(err)
	}

	if err = proto.Unmarshal(data, req); err != nil {
		panic(err)
	}
	parameters := req.GetParameter()

	generator := &Generator{
		Request:  req,
		Response: resp,
	}

	generator.setParameter(parameters)
	protoPath = generator.ProtoPath

	err = generator.generateCode()
	if err != nil {
		panic(err)
	}

	marshalled, err := proto.Marshal(resp)
	if err != nil {
		panic(err)
	}
	_, _ = os.Stdout.Write(marshalled)
}

func (generator *Generator) getServices() (ret map[string]Service) {
	ret = map[string]Service{}
	protoFiles := generator.Request.ProtoFile
	for _, filename := range generator.Request.FileToGenerate {
		p := protoFiles[len(protoFiles)-1]
		services := p.GetService()
		if len(services) == 0 {
			log.Println("No services in file:" + filename)
			return
		}
		opts := p.GetOptions()
		mainPckName = getMainPck(*p.Package)
		if mainPckName == "" {
			log.Println("Cannot find main package in file:" + filename)
			return
		}
		protoFileContent := ""
		if protoPath != "" {
			b, err := os.ReadFile(protoPath + filename)
			if err != nil {
				log.Fatal(err)
			}
			protoFileContent = string(b)
		}
		var (
			s        = services[0]
			rpcList  []Rpc
			useEmpty = false
		)
		for _, m := range s.GetMethod() {
			request := detectEmpty(removePackage(m.GetInputType()), &useEmpty)
			response := detectEmpty(removePackage(m.GetOutputType()), &useEmpty)
			requestDesc, _ := findMessageDesc(request, protoFileContent)
			responseDesc, _ := findMessageDesc(response, protoFileContent)

			messages := findAllRefs(
				messageFromProto{fromProto: protoFileContent, desc: requestDesc},
				messageFromProto{fromProto: protoFileContent, desc: responseDesc})

			rpcOpts := ""
			if protoFileContent != "" {
				rpcOpts = getRpcOptions(m.GetName(), protoFileContent)
			}
			rpcList = append(rpcList, Rpc{
				Name:         m.GetName(),
				Request:      request,
				RequestDesc:  requestDesc,
				Response:     response,
				ResponseDesc: responseDesc,
				Messages:     messages,
				Scopes:       getScopes(rpcOpts),
				PushEvent:    isPushEvent(rpcOpts),
				Public:       isPublic(rpcOpts),
				Debug:        isDebug(rpcOpts),
			})
		}
		// CSharp specific
		ns := *opts.CsharpNamespace
		t := strings.Split(ns, ".")
		var index = len(t) - 1
		if t[index] == "Proto" {
			index = len(t) - 2
		}
		csharpName := t[index]

		ret[filename] = Service{
			Package:              p.GetPackage(),
			GoPackage:            opts.GoPackage,
			CsharpServiceName:    csharpName,
			CsharpProtoNamespace: opts.CsharpNamespace,
			Name:                 s.GetName(),
			ProtoName:            filename[0 : len(filename)-6],
			Methods:              rpcList,
			UseEmpty:             useEmpty,
		}

	}
	return ret
}

func (generator *Generator) CreateServiceFile(filename string, service Service) error {
	// Create a file and append it to the output files
	var outfileName string
	var content = "// Code generated by protoc-gen-ws-rpc. DO NOT EDIT.\n"

	// Output file name based on template name
	var ext = generator.Template[0 : len(generator.Template)-len(".template")]
	var folderName = service.ProtoName
	outfileName = strings.Replace(filename, ".proto", ext, -1)

	if ext[len(ext)-2:] == "cs" {
		folderName = service.CsharpServiceName
		ext = strings.ToUpper(ext[0:1]) + ext[1:]
		outfileName = service.CsharpServiceName + ext
	}
	outfileName = "/" + folderName + "/" + outfileName

	var generatedFile plugin.CodeGeneratorResponse_File
	generatedFile.Name = &outfileName

	funcMap := template.FuncMap{
		"ToLower":     strings.ToLower,
		"Title":       strings.Title,
		"CleanChar":   cleanChar,
		"ToKebabCase": kebabCase,
	}
	var f, err = template.New(generator.Template).Funcs(funcMap).ParseFiles(generator.Template)
	if err != nil {
		log.Fatal("Template error: ", err)
	}
	var tpl bytes.Buffer

	err = f.Execute(&tpl, service)
	if err != nil {
		log.Print(err)
	}

	content += tpl.String()
	generatedFile.Content = &content
	generator.Response.File = append(generator.Response.File, &generatedFile)
	log.Printf("Generated Service File: %s \n\n", outfileName)
	return nil
}

func (generator *Generator) generateWsServices() error {
	services := generator.getServices()
	for filename, service := range services {
		_ = generator.CreateServiceFile(filename, service)
	}
	return nil
}

func (generator *Generator) generateCode() error {
	// Initialize the output file slice
	files := make([]*plugin.CodeGeneratorResponse_File, 0)
	generator.Response.File = files
	err := generator.generateWsServices()
	if err != nil {
		return err
	}
	return nil
}

func (generator *Generator) setParameter(parameters string) {
	params := strings.Split(parameters, ",")
	for _, element := range params {
		kv := strings.Split(element, "=")
		if len(kv) > 1 {
			if kv[0] == "template" {
				var t = kv[1]
				if t[0:2] == "./" {
					t = t[2:]
				}
				generator.Template = t
			}
			if kv[0] == "path" {
				generator.ProtoPath = kv[1]
			}
		}
	}
	if generator.Template[len(generator.Template)-9:] != ".template" {
		log.Println("Provide a .template file using --ws-rpc_opt=template=file.template")
		os.Exit(1)
	}
	log.Println("Using template:", generator.Template)
}
